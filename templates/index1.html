<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Customizable Sikku Kolam</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<style>
body { text-align: center; font-family: Arial; }
canvas { border: 1px solid #aaa; margin-top: 10px; }
.controls { margin: 15px; }
</style>
</head>
<body>
<h2>Customizable Sikku Kolam Generator</h2>
<div class="controls">
  Pattern:
  <select id="pattern">
    <option value="classic">Classic Square</option>
    <option value="flower">Flower / Radial Grid</option>
    <option value="diamond">Diamond</option>
    <option value="radialcircle">Radial Full Circle</option>
  </select>
  Arc Type:
  <select id="arctype">
    <option value="quarter">Quarter / Half Loops</option>
    <option value="full">Full Circle</option>
  </select>
  Rows: <input type="number" id="rows" value="5" min="2">
  Cols: <input type="number" id="cols" value="5" min="2">
  Radius: <input type="number" id="radius" value="30" min="5">
  Base Color: <input type="color" id="baseColor" value="#0064C8">
  <label><input type="checkbox" id="skipAnim"> Skip Animation</label>
  <button onclick="generateKolam()">Generate Kolam</button>
  <button onclick="restartAnimation()">Replay</button>
</div>

<script>
let spacing = 60;
let radius = 30;
let dots = [];
let path = [];
let t = 0;
let rows = 5, cols = 5;

function setup() {
  createCanvas(600, 600);
  strokeWeight(2);
  noFill();
  generateKolam();
}

function draw() {
  background(255);

  let skipAnimation = document.getElementById("skipAnim").checked;

  // Draw dots
  fill(0);
  noStroke();
  for (let d of dots) circle(d.x, d.y, 6);

  // Draw arcs/circles
  noFill();
  for (let i=0; i<(skipAnimation?path.length:int(t)); i++) {
    let p = path[i];
    stroke(p.color);
    if(p.full) ellipse(p.x,p.y,radius*2,radius*2);
    else arc(p.x,p.y,radius*2,radius*2,p.start,p.end);
  }

  if(!skipAnimation && t<path.length) t+=0.05;
}

function generateKolam() {
  dots=[];
  path=[];
  t=0;

  let pattern = document.getElementById("pattern").value;
  let arctype = document.getElementById("arctype").value;
  rows = int(document.getElementById("rows").value);
  cols = int(document.getElementById("cols").value);
  radius = int(document.getElementById("radius").value);
  let baseColor = document.getElementById("baseColor").value;

  if(pattern==="classic" || pattern==="flower") {
    generateGridPattern(pattern);
    generatePathClassic(arctype, baseColor);
  } else if(pattern==="diamond") {
    generateDiamondPattern();
    generatePathDiamond(arctype, baseColor);
  } else if(pattern==="radialcircle") {
    generateRadialPattern(arctype, baseColor);
  }
}

// -- GRID PATTERNS --
function generateGridPattern(pattern){
  let offsetX = width/2-(cols-1)*spacing/2;
  let offsetY = height/2-(rows-1)*spacing/2;

  if(pattern==="classic"){
    for(let r=0;r<rows;r++)
      for(let c=0;c<cols;c++)
        dots.push({x:offsetX+c*spacing, y:offsetY+r*spacing, row:r, col:c, layer:r});
  } else if(pattern==="flower"){
    let centerX=width/2, centerY=height/2;
    let layers = Math.min(rows,cols);
    for(let r=0;r<layers;r++)
      for(let c=0;c<layers;c++)
        if((r+c)%2===0){
          let x=centerX+(c-layers/2)*spacing;
          let y=centerY+(r-layers/2)*spacing;
          dots.push({x:x,y:y,row:r,col:c,layer:r});
        }
  }
}

// -- CLASSIC PATH --
function generatePathClassic(arctype, baseColor){
  for(let r=0;r<rows;r++){
    let leftToRight = r%2===0;
    for(let c = leftToRight?0:cols-1; leftToRight?c<cols:c>=0; leftToRight?c++:c--){
      let dot = dots[r*cols+c]||dots[0];
      let color = colorCycle(dot.layer, baseColor);
      if(arctype==="full") path.push({x:dot.x,y:dot.y,full:true,color:color});
      else{
        if((r+c)%2===0){
          path.push({x:dot.x,y:dot.y,start:0,end:HALF_PI,color:color});
          path.push({x:dot.x,y:dot.y,start:PI,end:PI+HALF_PI,color:color});
        } else{
          path.push({x:dot.x,y:dot.y,start:HALF_PI,end:PI,color:color});
          path.push({x:dot.x,y:dot.y,start:PI+HALF_PI,end:TWO_PI,color:color});
        }
      }
    }
  }
}

// -- DIAMOND PATTERN --
function generateDiamondPattern(){
  let centerX=width/2, centerY=height/2;
  dots=[];
  for(let r=-rows+1;r<rows;r++)
    for(let c=-cols+1;c<cols;c++)
      if(Math.abs(r+c)%2===0){
        let x=centerX+c*spacing;
        let y=centerY+r*spacing;
        let layer=Math.abs(r);
        dots.push({x:x,y:y,row:r,col:c,layer:layer});
      }
}

function generatePathDiamond(arctype, baseColor){
  let sortedDots = dots.slice().sort((a,b)=>a.y-b.y||a.x-b.x);
  let currentY=null;
  let rowDots=[];
  for(let dot of sortedDots){
    if(currentY===null || Math.abs(dot.y-currentY)<1) rowDots.push(dot), currentY=dot.y;
    else{ addRowToPath(rowDots,arctype,baseColor); rowDots=[dot]; currentY=dot.y;}
  }
  if(rowDots.length>0) addRowToPath(rowDots,arctype,baseColor);
}

function addRowToPath(rowDots,arctype,baseColor){
  let leftToRight=true;
  for(let i=0;i<rowDots.length;i++){
    let idx=leftToRight?i:rowDots.length-1-i;
    let dot=rowDots[idx];
    let color=colorCycle(dot.layer, baseColor);
    if(arctype==="full") path.push({x:dot.x,y:dot.y,full:true,color:color});
    else{
      if(i%2===0){ path.push({x:dot.x,y:dot.y,start:0,end:HALF_PI,color:color}); path.push({x:dot.x,y:dot.y,start:PI,end:PI+HALF_PI,color:color}); }
      else{ path.push({x:dot.x,y:dot.y,start:HALF_PI,end:PI,color:color}); path.push({x:dot.x,y:dot.y,start:PI+HALF_PI,end:TWO_PI,color:color}); }
    }
  }
}

// -- RADIAL PATTERN --
function generateRadialPattern(arctype, baseColor){
  let centerX=width/2, centerY=height/2;
  let layers=Math.min(rows,cols);
  for(let r=0;r<layers;r++){
    let numDots=r*6+6;
    let radiusLayer=spacing*(r+1);
    for(let i=0;i<numDots;i++){
      let angle=TWO_PI*i/numDots;
      let x=centerX+radiusLayer*cos(angle);
      let y=centerY+radiusLayer*sin(angle);
      dots.push({x:x,y:y,row:r,col:i,layer:r});
      let color=colorCycle(r,baseColor);
      if(arctype==="full") path.push({x:x,y:y,full:true,color:color});
      else path.push({x:x,y:y,start:0,end:HALF_PI,color:color});
    }
  }
}

// Set p5 to use HSB (Hue, Saturation, Brightness) mode
function setup() {
  createCanvas(600, 600);
  colorMode(HSB, 360, 100, 100); // H:0-360, S/B:0-100
  strokeWeight(2);
  noFill();
  generateKolam();
}

// -- COLOR CYCLING BASED ON LAYER (HSB mode) --
function colorCycle(layer, base){
  // base is still hex, convert to p5 color
  let c = color(base);
  let h = hue(c);
  let s = saturation(c);
  let b = brightness(c);
  
  // subtle hue shift per layer
  let newHue = (h + layer * 10) % 360; // 10 degrees per layer
  return color(newHue, s, b);
}
function restartAnimation(){ t=0; }
</script>
</body>
</html>